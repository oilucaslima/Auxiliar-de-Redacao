<h1 align="center" font-size="200em"><b>O Auxiliar de Reda√ß√£o</b></h1>

<div align = "center" >
<!-- imagem -->

[![requirement](https://img.shields.io/badge/IDE-Visual%20Studio%20Code-informational)](https://code.visualstudio.com/docs/?dv=linux64_deb)
![Make](https://img.shields.io/badge/Compilacao-Make-orange)
![Linguagem](https://img.shields.io/badge/Linguagem-C%2B%2B-blue)
</div>

## üìåSum√°rio
- [Introdu√ß√£o](#Introdu√ß√£o)
- [Objetivos](#Objetivos)
- [Arquivos](#Arquivos)
- [Resolu√ß√£o do Problema](#Resolu√ß√£o-do-problema)
- [Fun√ß√µes](#Fun√ß√µes)
- [Resultados](#Resultados)
- [Conclus√£o](#Conclus√£o)
- [Refer√™ncias](#Refer√™ncias)
- [Compila√ß√£o e execu√ß√£o](#Compila√ß√£o-e-execu√ß√£o)
- [Contato](#Contato)

## ‚úíÔ∏èIntrodu√ß√£o
<p align="justify">
Este √© um programa desenvolvido em C++ para a disciplina de Algoritmos e Estruturas de Dados I. 
Levando em considera√ß√£o que a publica√ß√£o dos resultados de pesquisa √© um est√°gio essencial no trabalho cient√≠fico. Normalmente, esses resultados s√£o compartilhados por meio de artigos em confer√™ncias e revistas cient√≠ficas, ap√≥s passarem por uma revis√£o rigorosa de forma e conte√∫do. Infelizmente, √© comum encontrar artigos acad√™micos que apresentam dificuldades de leitura, al√©m de conter erros de ortografia e gram√°tica. Partindo desse problema desenvolveu-se este algoritmo.
</p>

## üíªObjetivos

O objetivo deste trabalho consiste em especificar, projetar e implementar um sistema que facilite o processo de reda√ß√£o. Para alcan√ßar esse objetivo, √© fundamental realizar um cuidadoso projeto das estruturas de dados e dos algoritmos correspondentes, com o intuito de garantir a efici√™ncia do sistema na pr√°tica.

<strong><h4>Condi√ß√µes impostas: </h4></strong>
- A princ√≠pio este c√≥digo reealiza a leitura de um arquivo de entrada intitulado ```entrada.txt```, o qual cont√©m o texto a ser analisado.
- As senten√ßas s√£o definidas pelos sinais de pontua√ß√£o (".", "?", "!").
- Cada par√°grafo √© separado por uma linha em branco.
- Existe um arquivo de ```stop words``` para an√°lise. Sendo as stop words artigos e conjun√ß√µes que podem ser alteradas de acordo com a prefer√™ncia do usu√°rio.
- Existe um arquivo de ```expressoes``` para an√°lise. Sendo essas express√µes formadas por uma ou mais palavras, que podem ser alteradas de acordo com a prefer√™ncia do usu√°rio.
- A sa√≠da vai fornecer os dados ap√≥s a an√°lise do arquivo de entrada.


## üìÑArquivos
- <strong>Main.cpp:</strong> Leitura dos arquivos ```entrada.txt```, ```stopwords.txt``` e ```expressoes.txt```,  tempo de execu√ß√£o do c√≥digo e √© realizada a chamada das fun√ß√µes necess√°rios para o funcionamento.
- <strong>models.hpp:</strong> Declara√ß√£o das structs ```WordInfo```, ```Sentenca```, ```ParagraphInfo```, ```Expression```.
- <strong>functions.hpp:</strong> Declara√ß√£o das fun√ß√µes.
- <strong>header.cpp:</strong> Inclus√£o das bibliotecas e arquivos utilizados.
- <strong>functions.cpp:</strong> Desenvolvimento das fun√ß√µes. 
- <strong>aho.hpp:</strong> Implementa√ß√£o da estrutura Aho Corasick.
- <strong>Output.txt:</strong> A sa√≠da do programa.
- <strong>data/entrada.txt:</strong> Texto de entrada.
- <strong>data/stopwords.txt:</strong> Stop words, como por exemplo, para artigo (a, o, as,os) e para conjun√ß√µes (e, ou).
- <strong>data/expressoes.txt:</strong> Express√µes, como por exemplo, (uma vez que, sendo assim).

## üî®Resolu√ß√£o do problema

Visando encontrar uma solu√ß√£o eficiente e r√°pida para resolu√ß√£o do problema, foram usadas as seguintes estruturas de dados:

<h3><b>Aho Corasick</b></h3>

Aho-Corasick que √© uma t√©cnica poderosa usada para a busca eficiente de m√∫ltiplos padr√µes em um texto. Ela combina os conceitos de uma √°rvore TRIE e aut√¥matos de estado finito para realizar essa tarefa de forma otimizada.

A √°rvore TRIE (tamb√©m conhecida como √°rvore de prefixos) √© uma estrutura de dados especializada para armazenar e buscar palavras ou sequ√™ncias de caracteres. Ela possui uma estrutura hier√°rquica, na qual cada n√≥ representa um caractere e as arestas representam a transi√ß√£o entre os caracteres. Essa estrutura √© ideal para a busca de padr√µes, pois permite uma correspond√™ncia r√°pida e eficiente.

<div align="center">
  <img src="imagens/aho.jpg" width="50%" height="50%">
  <p align="center"><em> Exemplifica√ß√£o da Aho Corasick </em></p>
</div>


No Aho-Corasick, os aut√¥matos de estado finito s√£o utilizados para otimizar a busca por m√∫ltiplos padr√µes. Eles permitem a transi√ß√£o entre os estados de forma eficiente, reduzindo a necessidade de comparar todos os padr√µes em cada posi√ß√£o do texto pois permite a busca de m√∫ltiplos padr√µes simultaneamente.

A Aho possui complexidade de busca linear em rela√ß√£o ao tamanho da string de entrada mais o tamanho total de todos os padr√µes buscados e tem como complexidade de tempo: O(n + l + z), onde 'n' √© o comprimento do texto, 'l' √© o comprimento das palavras-chave e 'z' √© o n√∫mero de correspond√™ncias. O custo do seu espa√ßo auxiliar √© O(l * q), onde ‚Äòq‚Äô √© o comprimento do alfabeto, pois √© o n√∫mero m√°ximo de filhos que um n√≥ pode ter.
Essa estrutura explora as similaridades entre os padr√µes para reduzir a quantidade de dados necess√°rios para represent√°-los e consegue mant√©m um bom desempenho mesmo quando h√° padr√µes muito longos e ainda se houver padr√µes que se sobrep√µem parcial ou completamente, ambos ser√£o encontrados.

<h3><b>Map</b></h3>

A estrutura map mant√©m os elementos ordenados com base nas chaves, o que √© √∫til quando √© para iterar pelos elementos em uma ordem espec√≠fica, possui uma complexidade de O(log n), onde n √© o n√∫mero de elementos no mapa. Isso ocorre porque os elementos s√£o organizados em uma √°rvore bin√°ria balanceada, o que permite uma busca r√°pida.

<h3><b>Unodered map</b></h3>

O  unordered map armazena os elementos em uma tabela de hash, permitindo inser√ß√£o e busca muito r√°pidas, com complexidade m√©dia de O(1). Isso √© especialmente vantajoso quando a velocidade de acesso √© uma considera√ß√£o importante. Ao contr√°rio do map, o unordered map n√£o mant√©m uma ordem espec√≠fica nos elementos. 

<h3><b>Tabela Hash</b></h3>

A estrutura de tabela hash permite uma busca eficiente em m√©dia, com complexidade de tempo m√©dio O(1). Isso ocorre porque ela usa uma fun√ß√£o de hash para calcular o √≠ndice de armazenamento de cada elemento, permitindo um acesso direto aos dados, sem a necessidade de percorrer todos os elementos. Al√©m disso, as tabelas hash utilizam uma quantidade de espa√ßo razo√°vel para armazenar os elementos e garantir um bom desempenho. A aloca√ß√£o de espa√ßo √© feita com base no n√∫mero esperado de elementos e a capacidade √© automaticamente ajustada conforme necess√°rio, evitando desperd√≠cio de mem√≥ria.


## üî® Fun√ß√µes 

<h3><b>Par√¢metros gerais do texto e stop words</b></h3>

- ```addStopWord:``` Durante a leitura do arquivo que cont√©m as stop words, elas s√£o adicionadas em um ```unordered_map```. Caso ela j√° esteja nesse unordered map, incrementa-se em 1 o seu n√∫mero de ocorr√™ncias e salva-se a linha em que ela est√°, usando a fun√ß√£o ```existentWordUnorderedMap```.

- ```returnWord:``` Analisa cada caracter do arquivo de entrada, concatenando-o em uma palavra at√© que um caracter especial, como espa√ßo, v√≠rgula ou dois pontos apare√ßa, que indicar√° o final daquela palavra. No caso em que o caracter for um espa√ßo ou ```\n```, o contador da posi√ß√£o da palavra naquele par√°grafo √© incrementado em um. Tamb√©m no caso do caracter ser um ```\n```, incrementa-se 1 √† vari√°vel ```n``` que indica o n√∫mero da linha do arquivo atual. A cada palavra finalizada, chama-se a fun√ß√£o ```updateWord```. Sempre √© verificado se o par√°grafo acabou, atrav√©s da chamada da fun√ß√£o ``` updateParagrafo```.

- ```updateWord:``` Nessa fun√ß√£o, ser√° analisado se a palavra atual, n√£o sendo vazia, j√° foi lida, verificando o map de palavras. Caso positivo, incrementa-se em 1 o seu n√∫mero de ocorr√™ncias e adiciona-se em seu vector de refer√™ncias a linha atual, atrav√©s da fun√ß√£o ```existentWord```, insere-se a palavra no vector de senten√ßas daquele par√°grafo, usando a fun√ß√£o ```addVectorPalavraNaSentenca```, atualiza a ```tabelaHashPosicoes``` com a nova posi√ß√£o da palavra, al√©m de chamar a fun√ß√£o ```addVectorParagrafo``` para inserir a palavra no vector de palavras daquele par√°grafo que n√£o cont√©m palavras repetidas. A ```tabelaHashPosicoes``` √© utilizada para acessar, de maneira r√°pida, a posi√ß√£o da palavra no par√°grafo atual, sendo a chave da hash a pr√≥pria string e o conte√∫do armazenado um vector de pair, que guarda o √≠ndice do par√°grafo e a posi√ß√£o da palavra dentro dele. 
Caso a palavra ainda n√£o tenha sido lida anteriormente no texto, ela ser√° adicionada ao map, ser√° inserida no vector de senten√ßas, a ```tabelaHashPosicoes``` ser√° atualizada e a linha atual ser√° salva nas refer√™ncias. Caso a palavra esteja contida no unordered map de stop words, o contador de stop words √© incrementado em 1. A palavra √© reinicializada como vazia, para a leitura da pr√≥xima. 

- ```addVectorPalavraNaSentenca:``` Verifica-se se a palavra atual j√° foi adicionada anteriormente ao vector de palavras da senten√ßa com repeti√ß√£o, com a fun√ß√£o ```verificar```. Caso negativo, a palavra √© inserida tanto no vector de palavras da senten√ßa com repeti√ß√£o quanto sem repeti√ß√£o, caso contr√°rio, a palavra ser√° inserida apenas no vector com repeti√ß√£o. Em ambos os casos, √© utilizado a fun√ß√£o ```existePalavraNaSentenca```, que percorre o vector de palavras na senten√ßa sem repeti√ß√£o para encontrar o √≠ndice da palavra atual, e atualizar o vector que contem as posi√ß√µes com a posi√ß√£o atual.

- ```addVectorParagrafo:``` Verifica-se se a palavra atual j√° foi adicionada anteriormente ao vector de palavras do par√°grafo sem repeti√ß√£o, com a fun√ß√£o ```verificar2```. Caso positivo, o seu n√∫mero de ocorr√™ncias √© incrementado, e s√£o atualizados os vectors que cont√©m as linhas das apari√ß√µes e as posi√ß√µes, com a fun√ß√£o ```existePalavraNoParagrafo```. Caso negativo, adiciona-se a palabra no vector de palavras do par√°grafo sem repeti√ß√£o.

- ```updateSentenca:``` No caso em que o caracter √© '!', '.' ou '?', tem-se que a senten√ßa acabou. Nesses casos, o objeto da senten√ßa atual √© salvo na struct do seu par√°grafo correspondente. 

- ```updateParagrafo: ```No fim de cada concatena√ß√£o da palavra na fun√ß√£o ```returnWord```, verifica-se se o par√°grafo foi encerrado. Se o caracter atual for vazio e o anterior for um ```'\n'``` √© porque h√° uma linha vazia, logo o par√°grafo foi encerrado. Salva-se a linha final do par√°grafo anterior e a linha inicial do pr√≥ximo par√°grafo. As manipula√ß√µes dos objetos s√£o feitas na fun√ß√£o ```alocarParagrafo```.

- ```alocarParagrafo:``` S√£o salvos na struct do par√°grafo que foi finalizado: o n√∫mero de senten√ßas, o vector de objetos que cont√©m as senten√ßas propriamente ditas e o vector de objeto de senten√ßas sem repeti√ß√£o de palavras. Os contadores s√£o reinicializados, vectors t√™m sua mem√≥ria liberada, os dados do par√°grafo lido s√£o impressos no output e seu objeto √© salvo no vector de par√°grafos e √© deletado.

<h3><b>Express√µes</b></h3>

- ```add_string:``` Adiciona uma nova express√£o √† √°rvore de busca Trie. Ela recebe uma ```string s``` como entrada e percorre a √°rvore Trie, adicionando novos v√©rtices conforme necess√°rio para representar a string. Come√ßando pelo v√©rtice raiz, percorremos a string s caractere por caractere.
Para cada caractere, verificamos se h√° um filho correspondente no v√©rtice atual. Se n√£o houver, criamos um novo v√©rtice e o adicionamos como filho do v√©rtice atual.
Em seguida, atualizamos o v√©rtice atual para o novo v√©rtice criado e repetimos o processo para o pr√≥ximo caractere.
Ap√≥s percorrer toda a string s, marcamos o √∫ltimo v√©rtice como folha (indicando que uma express√£o termina nesse ponto) e atribu√≠mos um ID √∫nico √† express√£o. 

- ```prepare:``` Pr√©-processamento da √°rvore Trie para calcular os links de sufixo e os links de palavra final. Ela percorre a √°rvore em largura, calculando os links de sufixo para cada v√©rtice, o que permite uma busca eficiente na √°rvore. Come√ßando pelo v√©rtice raiz, usamos uma fila para percorrer a √°rvore em largura. Para cada v√©rtice na fila, calculamos o link de sufixo, que √© o caminho a seguir quando n√£o h√° correspond√™ncia com o caractere atual. Se o v√©rtice atual √© o v√©rtice raiz ou tem como pai o v√©rtice raiz, definimos o link de sufixo como o pr√≥prio v√©rtice raiz. Caso contr√°rio, seguimos o link de sufixo do pai at√© encontrar um v√©rtice com um filho correspondente ao caractere do v√©rtice atual. Esse ser√° o link de sufixo do v√©rtice atual. Al√©m disso, atualizamos o link de palavra final, que aponta para o v√©rtice mais pr√≥ximo que representa o sufixo da express√£o atual. Repetimos esse processo at√© percorrer toda a √°rvore em largura. 

- ```process:``` Realiza a busca de padr√µes na string de texto fornecida. Ela percorre a string de texto caractere por caractere, seguindo os links da √°rvore Trie. Sempre que um padr√£o √© encontrado, √© incrementado um contador e os √≠ndices e n√∫meros de linha correspondentes s√£o armazenados em vetores. Para cada caractere na string de texto, seguimos o link correspondente do v√©rtice atual na √°rvore Trie. Se n√£o h√° um link correspondente, voltamos ao v√©rtice raiz e continuamos a busca. Quando encontramos um v√©rtice folha, significa que uma express√£o foi encontrada. Incrementamos um contador de ocorr√™ncias e armazenamos o √≠ndice inicial da ocorr√™ncia na string de texto e o n√∫mero de linha correspondente. Repetimos esse processo para cada caractere na string de texto. 

- ```add_expressions:``` L√™ um arquivo de texto contendo uma express√£o por linha e adiciona a express√£o correspondente √† √°rvore Trie usando a fun√ß√£o ```add_string```. 


- ```process_text_file:``` L√™ um arquivo de texto completo e realiza o processamento da √°rvore Trie nesse texto. Ela primeiro l√™ o conte√∫do do arquivo e, em seguida, chama a fun√ß√£o process para buscar as ocorr√™ncias das express√µes na √°rvore Trie. Em seguida, exibe as ocorr√™ncias encontradas chamando a fun√ß√£o print_matches. Abre o arquivo especificado pelo nome de arquivo fornecido. L√™ o conte√∫do completo do arquivo de texto. 


- ```print_matches:```Exibe as ocorr√™ncias encontradas durante o processamento da √°rvore Trie.

- ```CalcSuffLink:``` Ap√≥s a constru√ß√£o da Trie, o algoritmo calcula os links de sufixo para cada n√≥. O link de sufixo de um n√≥ aponta para o n√≥ correspondente ao maior sufixo pr√≥prio desse n√≥ na Trie. Isso permite que o algoritmo salte rapidamente para um n√≥ correspondente quando n√£o h√° correspond√™ncia com um caractere. Al√©m dos links de sufixo, o algoritmo tamb√©m calcula os links de palavra final. O link de palavra final de um n√≥ aponta para o n√≥ correspondente ao maior sufixo pr√≥prio que √© uma palavra completa (um padr√£o) na Trie. Isso permite identificar rapidamente todas as ocorr√™ncias de padr√µes completos no texto.

<div align="center">
  <img src="imagens/link.jpg" alt="Pasta Dataset" width="350">
  <p align="center"><em> Exemplifica√ß√£o do link </em></p>
</div>

- ```getLineNumber:``` Representa o n√∫mero da linha correspondente ao √≠ndice na string.

<h3><b>Output</b></h3>

- ```iniciar_output:``` Impress√£o do cabe√ßalho.

- ```output_CadaParagrafo:``` Imprime as palavras contidas em cada par√°grafo, sem repeti-las, chamando a fun√ß√£o ```output_CadaSentenca```. Tamb√©m s√£o impressos o n√∫mero de palavras do par√°grafo com e sem stop words, al√©m da fun√ß√£o ```output_DistanciaPalavraParagrafo``` ser chamada para imprimir mais detalhes.

- ```output_CadaSentenca:``` Impress√£o dos seguintes dados de cada palavra: o par√°grafo e a senten√ßa atual, n√∫mero de ocorr√™ncia, linha das apari√ß√µes e posi√ß√µes. Realiza-se um c√°lculo, baseado no tamanho de cada palavra e de seus dados, para manter a impress√£o organizada e centralizada.

- ```output_DistanciaPalavraParagrafo:``` S√£o impressas as dist√¢ncias das palavras que aparecem mais de uma vez naquele par√°grafo, em rela√ß√£o √† primeira apari√ß√£o. Tamb√©m mostra-se a linha de in√≠cio do par√°grafo e seu n√∫mero de senten√ßas.

- ```output_Full:``` Impres√£o de todas as palavras do texto, em ordem alfab√©tica, al√©m de todos os par√°grafos e linhas que elas aparecem, n√∫mero total de ocorr√™ncias e todas suas posi√ß√µes. √â mostrado, al√©m disso, dados gerais do texto, como o n√∫mero de palavras em cada senten√ßa com e sem stop words, e a linha inicial e n√∫mero de senten√ßas de todos os par√°grafos.

- ```removerAcento:``` Verifica se a palavra tem acento e retorna seu tamanho, visando evitar poss√≠veis erros de alinhamento no output.

## üéØResultados

A sa√≠da deve atender os seguintes crit√©rios:

1. Para cada par√°grafo do texto:

- O n√∫mero da linha no arquivo fonte onde o par√°grafo inicializa e termina;
- O n√∫mero de senten√ßas existentes no par√°grafo;
- O n√∫mero de palavras de cada senten√ßa incluindo e descartando as "stop words";

2. Para cada palavra que n√£o √© stop word:
- Cada palavra listada em ordem alfab√©tica com a frequ√™ncia de sua ocorr√™ncia no texto, indicando as linhas do arquivo onde essas surgem.
- Em caso cuja palavra apare√ßa mais de uma vez em um mesmo par√°grafo, indicar a sua ocorr√™ncia e a dist√¢ncia entre elas incluindo as stop words.

3. Ocorr√™ncia de certas express√µes sendo que para cada express√£o deve ser indicado a linha no arquivo fonte onde aparece. 

<h3><b>Entrada</b></h3>
<img src="imagens/entrada.jpg">

<h3><b>Resultados parciais</b></h3>
<img src="imagens/p1.jpg">
<img src="imagens/p2.jpg">
<img src="imagens/p3.jpg">
<img src="imagens/distancia.jpg">
<img src="imagens/distancia2.jpg">
<img src="imagens/ep.jpg">

<h3><b>Resultado completo</b></h3>
<img src="imagens/full.jpg">

<h3><b>Dados gerais</b></h3>
<img src="imagens/dados.jpg">

<h3><b>Tempo de execu√ß√£o</b></h3>
47.8589 milisegundos

Para analisar o custo assist√≥tico do Auxiliar de Reda√ß√£o implementado neste trabalho, verificar cada fun√ß√£o e manipula√ß√£o seria extremamente trabalhoso e impreciso, portanto definiu-se que a melhor forma de realizar essa an√°lise seria observar a rela√ß√£o entre o n√∫mero de linhas da entrada e o tempo de execu√ß√£o. Obteve-se como resultado a seguinte tabela:

 | N√∫mero de linhas                |  Tempo de execu√ß√£o (ms)    |                     
 | --------------------------------| ---------------------------|
 |  1000                           | 2331.4140                  |
 |  2000                           | 4756.0379                  |
 |  3000                           | 7245.5451                  |
 |  4000                           | 8269.3266                  |
 |  5000                           | 12878.3538                 |
 |  6000                           | 15438.6355                 |
 |  7000                           | 18291.2761                 |
 |  8000                           | 19424.3799                 |
 |  9000                           | 22968.5542                 |
 |  10000                          | 25343.7800                 |
 |  11000                          | 28400.1168                 |
 |  12000                          | 29681.4185                 |
 |  13000                          | 31635.1776                 |
 |  14000                          | 36498.4227                 |
 |  15000                          | 40089.7591                 |

A partir da tabela, gerou-se o gr√°fico visando observar o comportamento do tempo de execu√ß√£o em fun√ß√£o do n√∫mero de linhas da entrada, sendo poss√≠vel determinar o custo assint√≥tico do algoritmo:
<div align="center">
  <img src="imagens/grafico.png" width="50%" height="50%">
  <p align="center"><em> N√∫mero de linhas x Tempo de execu√ß√£o </em></p>
</div>

## ‚úîÔ∏èConclus√£o

O projeto Auxiliar de Reda√ß√£o √© uma ferramenta √∫til para auxiliar escritores, pesquisadores e estudantes na revis√£o e an√°lise de textos.
A utiliza√ß√£o de estruturas de dados como √°rvore, fila, vetores, map, unodered map e tabela hash, permitiu a organiza√ß√£o e busca eficiente das informa√ß√µes do texto. Os algoritmos implementados garantiram o processamento correto das senten√ßas, a contagem adequada das palavras e a identifica√ß√£o das express√µes e stop words desejadas.

A partir da observa√ß√£o do gr√°fico que exprime a rela√ß√£o entre o n√∫mero de linhas da entrada e o tempo de execus√£o, v√™-se que foi obtido aproximadamente uma reta. Portanto, √© poss√≠vel concluir que o algoritmo de implementa√ß√£o do Auxiliar de Reda√ß√£o possui um custo computacional da classe linear.


## ‚úîÔ∏èRefer√™ncias
- https://www.geeksforgeeks.org/aho-corasick-algorithm-pattern-searching/
- https://www.tutorialspoint.com/aho-corasick-algorithm-for-pattern-searching-in-cplusplus
- https://acervolima.com/algoritmo-aho-corasick-para-pesquisa-de-padroes/
- https://www.youtube.com/watch?v=kKQLjWFf4nE&ab_channel=MarcosAndr%C3%A9SilveiraKutova


## üëæCompila√ß√£o e execu√ß√£o
* Especifica√ß√µes da m√°quina em que o c√≥digo foi rodado:
  * Processador Intel Core i5, 7th Gen;
  * Sistema Operacional Windows 10;
  * Terminal do WSL: Ubuntu 20.04.5;
  * 8GB de RAM.
* | Comando                |  Fun√ß√£o                                                                                           |                     
  | -----------------------| ------------------------------------------------------------------------------------------------- |
  |  `make clean`          | Apaga a √∫ltima compila√ß√£o realizada contida na pasta build                                        |
  |  `make`                | Executa a compila√ß√£o do programa utilizando o gcc, e o resultado vai para a pasta build           |
  |  `make run`            | Executa o programa da pasta build ap√≥s a realiza√ß√£o da compila√ß√£o                                 |

## Contato

<div>
 <br><p align="justify"> Anna Laura Moura Santana</p>
 <a href="https://t.me/annalaurams">
 <img align="center" src="https://img.shields.io/badge/Telegram-2CA5E0?style=for-the-badge&logo=telegram&logoColor=white"/> 
 </div>
<a style="color:black" href="mailto:nalauramoura@gmail.com?subject=[GitHub]%20Source%20Dynamic%20Lists">
‚úâÔ∏è <i>nalauramoura@gmail.com</i>
</a>

<div>
 <p align="justify"> Julia Rezende Gomes Rocha</p>
 <a href="https://t.me/juliarezende34">
 <img align="center" src="https://img.shields.io/badge/Telegram-2CA5E0?style=for-the-badge&logo=telegram&logoColor=white"/> 
 </div>
<a style="color:black" href="mailto:juliarezende34@gmail.com?subject=[GitHub]%20Source%20Dynamic%20Lists">
‚úâÔ∏è <i>juliarezende34@gmail.com</i>
</a>
 
<div>
 <br><p align="justify"> Jullia Fernandes Felizardo</p>
 <a href="https://t.me/JulliaFernandes">
 <img align="center" src="https://img.shields.io/badge/Telegram-2CA5E0?style=for-the-badge&logo=telegram&logoColor=white"/> 
 </div>
<a style="color:black" href="mailto:julliacefet@gmail.com?subject=[GitHub]%20Source%20Dynamic%20Lists">
‚úâÔ∏è <i>julliacefet@gmail.com</i>
</a>

<div>
 <br><p align="justify"> Let√≠cia de Oliveira Silva</p>
 <a href="https://t.me/letolsilva">
 <img align="center" src="https://img.shields.io/badge/Telegram-2CA5E0?style=for-the-badge&logo=telegram&logoColor=white"/> 
 </div>
<a style="color:black" href="mailto:letolsilva22@gmail.com?subject=[GitHub]%20Source%20Dynamic%20Lists">
‚úâÔ∏è <i>letolsilva22@gmail.com</i>
</a>

<div>
 <br><p align="justify"> Lucas Lima de Oliveira</p>
 <a href="https://t.me/lucas_lima37">
 <img align="center" src="https://img.shields.io/badge/Telegram-2CA5E0?style=for-the-badge&logo=telegram&logoColor=white"/> 
 </div>
<a style="color:black" href="mailto:lucaslimadeoliveira80@gmail.com?subject=[GitHub]%20Source%20Dynamic%20Lists">
‚úâÔ∏è <i>lucaslimadeoliveira80@gmail.com</i>
</a>

<div>
 <br><p align="justify"> Mariana Rodrigues Lamounier Melo</p>
 <a href="https://t.me/MariRodriguess0">
 <img align="center" src="https://img.shields.io/badge/Telegram-2CA5E0?style=for-the-badge&logo=telegram&logoColor=white"/> 
 </div>
<a style="color:black" href="mailto:mariana.itapec@gmail.com?subject=[GitHub]%20Source%20Dynamic%20Lists">
‚úâÔ∏è <i>mariana.itapec@gmail.com</i>
</a>

